(define-module (grafo bipartiteness)
  #:use-module (oop   goops)
  #:use-module (grafo graph)
  #:use-module (grafo utils)
  #:use-module (srfi  srfi-1)
  #:use-module (ice-9 q)
  #:use-module (vis-graph)
  #:export (bipartite?))

(define-method (bipartite? (g <undirected-graph>))
  (define (classify! v k)
    (add-atribute! g v #:class k)
    (label-vertex! v (obj->string k))
    (color-vertex! v (if (< k 0) #:green #:blue))
    (color-vertex-label! v (if (< k 0) #:green #:blue))
    (cpp-wait! (string-append "Classify vertex " (obj->string v) " as " (obj->string k))))
  (define (classified? v) (atribute? g v #:class))
  (define (class v) (value (atribute g v #:class)))
  (define is-bipartite? #true)
  (define q (make-q))
  (define x (choose (vertices g)))

  (classify! x 1)
  (enq! q x)
  (while (not (q-empty? q))
    (let ((v (deq! q)))
      (for-each (位 (u)
		   (cond ((and (classified? u) (equal? (class v) (class u)))
			  (set! is-bipartite? #false))
			 ((not (classified? u))
			  (classify! u (* -1 (class v)))
			  (enq! q u))))
		(adjacent g v))))
  (cpp-wait! (string-append "Algorithm finished... "
			    (if is-bipartite?
				"The graph is bipartite. Click step to clean up graoh"
				"The graph is not bipartite. Click step to see conflicted edges.")))
  (if is-bipartite?
      (begin
	(for-each (位 (v)
		     (uncolor-vertex! v)
		     (uncolor-vertex-label! v)
		     (label-vertex! v ""))
		  (vertices g)))
      (begin
	(for-each (位 (conficted)
		     (color-edge! conflicted #:red))
		  (filter (位 (e) (equal? (class (from e)) (class (to e)))) (edges g)))))
  is-bipartite?)
