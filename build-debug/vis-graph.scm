;(use-modules (oop goops))
;(use-modules (grafo graph))
;(use-modules (grafo utils))
;(use-modules (srfi srfi-1))
;(use-modules (ice-9 q))
;(use-modules (srfi srfi-43))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; CPP PROCEDURES WRAPPERS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define-method (color (k <keyword>))
  (cond ((equal? k #:red)
	 (list 196 2 51 100))
	((equal? k #:green)
	 (list 0 159 107 100))
	((equal? k #:blue)
	 (list 0 135 189 100))
	((equal? k #:yellow)
	 (list 255 211 0 100))))

(define (label-vertex! v msg)
  (cpp-label-node! v msg))

(define (label-edge! e msg)
  (cpp-label-edge! (from e) (to e) msg))

(define (label-arrow! a msg)
  (cpp-label-arrow! (from a) (to a) msg))

(define-method (color-vertex! v (k <keyword>))
  (define c (color k))
  (cpp-color-node! v (first c) (second c) (third c) (fourth c)))

(define (uncolor-vertex! v)
  (cpp-uncolor-node! v))

(define-method (color-edge! e (k <keyword>))
  (define c (color k))
  (cpp-color-edge! (from e) (to e) (first c) (second c) (third c) (fourth c)))

(define (uncolor-edge! e)
  (cpp-uncolor-edge! (from e) (to e)))

(define-method (color-arrow! a (k <keyword>))
  (define c (color k))
  (cpp-color-arrow! (from a) (to a) (first c) (second c) (third c) (fourth c)))

(define (uncolor-arrow! a)
  (cpp-uncolor-arrow! (from a) (to a)))

(define-method (color-vertex-label! v (k <keyword>))
  (define c (color k))
  (cpp-color-node-label! v (first c) (second c) (third c) (fourth c)))

(define (uncolor-vertex-label! v)
  (cpp-uncolor-node-label! v))

(define-method (color-edge-label! e (k <keyword>))
  (define c (color k))
  (cpp-color-edge-label! (from e) (to e) (first c) (second c) (third c) (fourth c)))

(define (uncolor-edge-label! e)
  (cpp-uncolor-edge-label! (from e) (to e)))

(define-method (color-arrow-label! a (k <keyword>))
  (define c (color k))
  (cpp-color-arrow-label! (from a) (to a) (first c) (second c) (third c) (fourth c)))

(define (uncolor-arrow-label! a)
  (cpp-uncolor-arrow-label! (from a) (to a)))

(define (wait! . msg)
  (if (null? msg)
      (cpp-wait! "")
      (cpp-wait! (apply string-append msg))))

(define (show-message! . msg)
  (if (null? msg)
      (cpp-show-message! "")
      (cpp-show-message! (apply string-append msg))))

(define (reload! msg)
  (cpp-reload! msg))

(define (reload-this!)
  (cpp-reload! "vis-graph.scm"))

(define (vertex-pos v)
  (cpp-pos-node v))

(define (move-vertex! v dx dy)
  (cpp-move-node! v dx dy))


;; Constant values
(define vweight 1)
(define atraction .06)
(define repulsion 1000)
(define magic-mass 300)
(define friction 0)

;; Point arithmetic
(define (p x y) (cons x y))
(define (px P) (car P))
(define (py P) (cdr P))
(define (p+ A B) (p (+ (px A) (px B)) (+ (py A) (py B))))
(define (p- A B) (p (- (px A) (px B)) (- (py A) (py B))))
(define (p* x P) (p (* x (px P)) (* x (py P))))
(define (pdist* A B)
  (+ (expt (- (px A) (px B)) 2) (expt (- (py A) (py B)) 2)))
(define (pdist A B)
  (sqrt (pdist* A B)))

;; Auxiliary procedures
(define (delta! ht v op x)
  (hash-set! ht v (op (hash-ref ht v) x)))

(define-method (edge*? (g <undirected-graph>) (e <list>))
  (edge? g e))

(define-method (edge*? (g <directed-graph>) (a <list>))
  (arrow? g a))

(define (spring-step2)
  (define current-vertices (vertices G))
  ;; Data structures
  (define movement-tendency (make-hash-table))
  (define pixel-movement (make-hash-table))

  (for-each (lambda (v)
	      (hash-set! movement-tendency v (cons 0 0))
	      (hash-set! pixel-movement v (if (hash-ref pixel-movement v) (hash-ref pixel-movement v) (cons 0 0)))
	      
	      ;; Apply repulsion rule : Coulombs Law with custom constant and particle charge (involves all other vertices)
	      (for-each (lambda (u)
			  (unless (equal? u v)
			    (let ((d2 (pdist* (vertex-pos v) (vertex-pos u))))
			      (delta! movement-tendency v p+ (p* (/ (* repulsion vweight vweight) d2)
								 (p- (vertex-pos v) (vertex-pos u)))))))
			current-vertices)

	      ;; Apply atraction rule : Hooks Law with custom spring stiffness (involves neighbors)
	      (for-each (lambda (u)
			  (when (edge*? G (list v u))
			    (delta! movement-tendency v p+ (p* atraction (p- (vertex-pos u) (vertex-pos v))))))
			current-vertices)

	      ; left wall repulsion
	      (let* ((pleft (p -2500 (py (vertex-pos v))))
		     (d2 (pdist* (vertex-pos v) pleft)))
		(delta! movement-tendency v p+ (p* (/ (* repulsion vweight magic-mass) d2)
						   (p- (vertex-pos v) pleft))))

	      ;; right wall repulsion
	      (let* ((pright (p 2500 (py (vertex-pos v))))
		     (d2 (pdist* (vertex-pos v) pright)))
		(delta! movement-tendency v p+ (p* (/ (* repulsion vweight magic-mass) d2)
						   (p- (vertex-pos v) pright))))

	      ;; top wall repulsion
	      (let* ((ptop (p (px (vertex-pos v)) -2500))
		     (d2 (pdist* (vertex-pos v) ptop)))
		(delta! movement-tendency v p+ (p* (/ (* repulsion vweight magic-mass) d2)
						   (p- (vertex-pos v) ptop))))

	      ;; bottom wall repulsion
	      (let* ((pbottom (p (px (vertex-pos v)) 2500))
		     (d2 (pdist* (vertex-pos v) pbottom)))
		(delta! movement-tendency v p+ (p* (/ (* repulsion vweight magic-mass) d2)
						   (p- (vertex-pos v) pbottom))))

	      ;; Apply friction : Friction with custom constant (involves the current pixel movement)
	      (delta! movement-tendency v p+ (p* (- friction) (hash-ref movement-tendency v)))
	      
	      ;; Update the pixel movement
	      (delta! pixel-movement v p+ (hash-ref movement-tendency v)))
	    current-vertices)
  
  ;; Update the positions
  (for-each (lambda (v)
	      (let ((delta-pixels (hash-ref pixel-movement v)))
		(move-vertex! v (px delta-pixels) (py delta-pixels))))
	    current-vertices))

(define (spring-step)
  (define current-vertices (vertices G))
  ;; Data structures
  (define movement-tendency (make-hash-table))
  (define pixel-movement (make-hash-table))
  ;; Variables
  (define v-p '())
  (define v-px '())
  (define v-py '())
  (define u-p '())
  (define u-px '())
  (define u-py '())

  (for-each (lambda (v)
	      (hash-set! movement-tendency v (cons 0 0))
	      (hash-set! pixel-movement v (if (hash-ref pixel-movement v) (hash-ref pixel-movement v) (cons 0 0)))
	      (if (vertex? G v)
		  (set! v-p (vertex-pos v))
		  (set! v-p (cons 0 0)))
	      (set! v-px (px v-p))
	      (set! v-py (py v-p))
	      
	      ;; Apply repulsion rule : Coulombs Law with custom constant and particle charge (involves all other vertices)
	      (for-each (lambda (u)
			  (if (vertex? G u)
			      (set! u-p (vertex-pos u))
			      (set! u-p (cons 0 0)))
			  (set! u-px (px u-p))
			  (set! u-py (py u-p))
			  (unless (equal? u v)
			    (let ((d2 (pdist* v-p u-p)))
			      (delta! movement-tendency v p+ (p* (/ (* repulsion vweight vweight) d2)
								 (p- v-p u-p))))))
			current-vertices)

	      ;; Apply atraction rule : Hooks Law with custom spring stiffness (involves neighbors)
	      (for-each (lambda (u)
			  (if (vertex? G u)
			      (set! u-p (vertex-pos u))
			      (set! u-p (cons 0 0)))
			  (when (edge*? G (list v u))
			    (delta! movement-tendency v p+ (p* atraction (p- u-p v-p)))))
			current-vertices)

	      ; left wall repulsion
	      (let* ((pleft (p -2500 (py v-p)))
		     (d2 (pdist* v-p pleft)))
		(delta! movement-tendency v p+ (p* (/ (* repulsion vweight magic-mass) d2)
						   (p- v-p pleft))))

	      ;; right wall repulsion
	      (let* ((pright (p 2500 (py v-p)))
		     (d2 (pdist* v-p pright)))
		(delta! movement-tendency v p+ (p* (/ (* repulsion vweight magic-mass) d2)
						   (p- v-p pright))))

	      ;; top wall repulsion
	      (let* ((ptop (p (px (vertex-pos v)) -2500))
		     (d2 (pdist* v-p ptop)))
		(delta! movement-tendency v p+ (p* (/ (* repulsion vweight magic-mass) d2)
						   (p- v-p ptop))))

	      ;; bottom wall repulsion
	      (let* ((pbottom (p (px v-p) 2500))
		     (d2 (pdist* v-p pbottom)))
		(delta! movement-tendency v p+ (p* (/ (* repulsion vweight magic-mass) d2)
						   (p- v-p pbottom))))

	      ;; Apply friction : Friction with custom constant (involves the current pixel movement)
	      (delta! movement-tendency v p+ (p* (- friction) (hash-ref movement-tendency v)))
	      
	      ;; Update the pixel movement
	      (delta! pixel-movement v p+ (hash-ref movement-tendency v)))
	    current-vertices)
  
  ;; Update the positions
  (for-each (lambda (v)
	      (let ((delta-pixels (hash-ref pixel-movement v)))
		(when (vertex? G v)
		  (move-vertex! v (px delta-pixels) (py delta-pixels)))))
	    current-vertices))

(define spring-movement #false)
(define spring-counter 10000)
(define (spring)
  (when spring-movement
    (spring-step)
    (set! spring-counter 10000)
    (while (> spring-counter 0)
      (set! spring-counter (- spring-counter 1))))
  (spring))

(define (toggle-forces)
  (set! spring-movement (not spring-movement)))

(define (max-force steps)
  (define (iter i)
    (unless (zero? i)
      (spring-step)
      (iter (- i 1))))
  (define old-counter spring-counter)
  (define old-switch spring-movement)
  (set! spring-movement #false)
  (iter steps)
  (set! spring-counter old-counter)
  (set! spring-movement old-switch))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; CLASS DEFINITIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define-class <vis-undirected-graph> (<undirected-graph>))

(define-method (add-vertex! (g <vis-undirected-graph>) v x y)
  (define vertex-inserted? ((method-procedure (last (generic-function-methods add-vertex!))) g v))
  (when vertex-inserted?
    (cpp-paint-node! v x y)))

(define-method (add-vertex! (g <vis-undirected-graph>) v)
  (define vertex-inserted? (next-method))
  (when vertex-inserted?
    (cpp-paint-node! v 0 0)))

(define-method (remove-vertex! (g <vis-undirected-graph>) v)
  (define vertex-removed? (next-method))
  (when vertex-removed?
    (cpp-unpaint-node! v)))

(define-method (add-edge! (g <vis-undirected-graph>) (e <list>))
  (define edge-inserted? (next-method))
  (when edge-inserted?
    (cpp-paint-edge! (from e) (to e))))

(define-method (remove-edge! (g <vis-undirected-graph>) (e <list>))
  (define edge-removed? (next-method))
  (when edge-removed?
    (cpp-unpaint-edge! (from e) (to e))))


(define-class <vis-directed-graph> (<directed-graph>))

(define-method (add-vertex! (g <vis-directed-graph>) v x y)
  (define vertex-inserted? ((method-procedure (last (generic-function-methods add-vertex!))) g v))
  (when vertex-inserted?
    (cpp-paint-node! v x y)))

(define-method (add-vertex! (g <vis-directed-graph>) v)
  (define vertex-inserted? (next-method))
  (when vertex-inserted?
    (cpp-paint-node! v 0 0)))

(define-method (remove-vertex! (g <vis-directed-graph>) v)
  (define vertex-removed? (next-method))
  (when vertex-removed?
    (cpp-unpaint-node! v)))

(define-method (add-arrow! (g <vis-directed-graph>) (a <list>))
  (define arrow-inserted? (next-method))
  (when arrow-inserted?
    (cpp-paint-arrow! (from a) (to a))))

(define-method (remove-arrow! (g <vis-directed-graph>) (a <list>))
  (define arrow-removed? (next-method))
  (when arrow-removed?
    (cpp-unpaint-arrow! (from a) (to a))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; GRAPH GENERATORS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (remove-lonely! g)
  (for-each (lambda (v)
	       (when (zero? (length (incident g v)))
		 (remove-vertex! g v)))
	    (vertices g)))

(define-method (random-graph (g <undirected-graph>) numv nume)
  (for-each (lambda (i)
	       (add-vertex! g i (random 200) (random 200)))
	    (iota numv))
  (for-each (lambda (i)
	       (let ((u (random numv))
		     (v (random numv)))
		 (while (or (edge? g (list u v)) (equal? u v))
		   (set! u (random numv))
		   (set! v (random numv)))
		 (add-edge! g (list u v))))
	    (iota nume)))

(define-method (random-graph (g <directed-graph>) numv nume)
  (for-each (lambda (i)
	       (add-vertex! g i (random 200) (random 200)))
	    (iota numv))
  (for-each (lambda (i)
	       (let ((u (random numv))
		     (v (random numv)))
		 (while (or (arrow? g (list u v)) (equal? u v))
		   (set! u (random numv))
		   (set! v (random numv)))
		 (add-arrow! g (list u v))))
	    (iota nume)))

(define-method (random-connected-graph g numv nume)
  (random-graph g numv nume)
  (remove-lonely! g))

(define-method (random-connected-labeled-graph (g <undirected-graph>) numv nume min max)
  (define (rand min max) (+ (random (- (+ max 1) min)) min))
  (random-connected-graph g numv nume)
  (for-each (lambda (e)
	       (label-edge! e (obj->string (rand min max)))
	       (uncolor-edge-label! e))
	    (edges g)))

(define-method (random-connected-labeled-graph (g <directed-graph>) numv nume min max)
  (define (rand min max) (+ (random (- (+ max 1) min)) min))
  (random-connected-graph g numv nume)
  (for-each (lambda (e)
	       (label-arrow! e (obj->string (rand min max)))
	       (uncolor-arrow-label! e))
	    (arrows g)))

(define (random-complete g numv vfilter efilter)
  (define r (* 10 numv))
  (define k (/ (* 2 3.141592) numv))
  (for-each (lambda (v)
	       (add-vertex! g v
			    (* r (sin (* v k)))
			    (* r (cos (* v k)))))
	    (filter vfilter (iota numv)))
  (for-each (lambda (u)
	       (for-each (lambda (v)
			    (when (and (vertex? G u) (vertex? G v) (efilter (list u v)))
			      (add-edge! g (list u v))))
			 (iota (- numv u 1) (+ u 1))))
	    (iota numv)))

(define (complete-tree d b)
  (define (children x b)
    (map (lambda (i) (+ (* b x) i)) (iota b 1)))
  (define (tn b d)
    (cond ((< d 0) 0)
	  ((= d 0) 1)
	  (else (- (* (tn b (- d 1)) (+ b 1))
		   (* (tn b (- d 2)) b)))))
  (define (f i x y b w n)
    (define cs (children i b))
    (add-vertex! G i x y)
    (unless (>= (+ (* b i) 1) n)
      (for-each (lambda (ci)
		  (f (list-ref cs ci)
		     (+ x (/ w (* 2.0 b))
			(* ci (/ w b))
			(- (/ w 2.0)))
		     (+ y (* 40 b)) b (/ w b) n)
		  (add-edge! G (list i (list-ref cs ci))))
		(iota b))))
  (define n (tn b d))
  (f 0 0 0 b (* n 30) n))

(define (reduced-complete-graph g n p)
  (random-complete g n (lambda (x) #true) (lambda (x) #true))
  (for-each (lambda (v)
	       (for-each (lambda (e)
			    (if (<= (random 100) p)
				(remove-edge! g e)))
			 (incident g v)))
	    (vertices g))
  (remove-lonely! g))

(define (weighted-reduced-complete-graph g n)
  (reduced-complete-graph g n))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; BIPARTITENESS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define-method (run-bipartiteness (g <undirected-graph>))
  (if (zero? (length (vertices g)))
      (show-message! "NULL GRAPH can't be an input")
      (bipartite? g)))

(define-method (bipartite? (g <undirected-graph>))
  (define (classify! v k)
    (add-atribute! g v #:class k)
    (label-vertex! v (obj->string k))
    (color-vertex! v (if (< k 0) #:green #:blue))
    (color-vertex-label! v (if (< k 0) #:green #:blue))
    (wait! "Classify vertex " (obj->string v) " as " (obj->string k)))
  (define (classified? v) (atribute? g v #:class))
  (define (class v) (value (atribute g v #:class)))
  (define is-bipartite? #true)
  (define q (make-q))
  (define x (choose (vertices g)))

  (classify! x 1)
  (enq! q x)
  (while (not (q-empty? q))
    (let ((v (deq! q)))
      (for-each (lambda (u)
		   (cond ((and (classified? u) (equal? (class v) (class u)))
			  (color-edge! (list v u) #:red)
			  (set! is-bipartite? #false)
			  (wait! "Conflicted edge (" (obj->string v) " " (obj->string u) ")"))
			 ((not (classified? u))
			  (color-edge! (list v u) #:yellow)
			  (classify! u (* -1 (class v)))
			  (enq! q u))))
		(adjacent g v)))
    (when (q-empty? q)
      (let ((lst (remove classified? (vertices g))))
	(unless (null? lst)
	  (classify! (first lst) 1)
	  (enq! q (first lst))))))
  (if is-bipartite?
      (show-message! "The graph is bipartite.")
      (show-message! "The graph is not bipartite."))
  (wait!)
  (for-each (lambda (v)
	       (uncolor-vertex! v)
	       (uncolor-vertex-label! v)
	       (label-vertex! v ""))
	    (vertices g))
  (for-each (lambda (e)
	       (uncolor-edge! e))
	    (edges g))
  (remove-vertices-atribute! g #:class)
  is-bipartite?)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; SPANNING TREE BFS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define-method (run-spanning-tree-bfs (g <undirected-graph>) root)
  (spanning-tree-bfs g root))

(define-method (spanning-tree-bfs (g <undirected-graph>) root)
  (define tree (make <undirected-graph>))
  (breath-first-search g root
		       (lambda (v)
			  (color-vertex! v #:green)
			  (wait! "Vertex " (obj->string v) " added to spanning tree.")
			  (add-vertex! tree v))
		       (lambda (u v)
			  (color-edge! (list u v) #:green)
			  (wait! "Edge " (obj->string (list u v)) " added to spanning tree.")
			  (add-edge! tree (list u v)))
		       (lambda (lst)
			  (sort lst <)))
  (if (= (length (vertices g)) (length (vertices tree)))
      (begin
	(show-message! "Spanning Tree obtained")
	(wait! "Clean graph")
	(for-each (lambda (v) (uncolor-vertex! v)) (vertices g))
	(for-each (lambda (e) (uncolor-edge! e)) (edges g))
	tree)
      (begin
	(show-message! "The graph doesn't have a spanning tree")
	(wait! "Clean graph")
	(for-each (lambda (v) (uncolor-vertex! v)) (vertices g))
	(for-each (lambda (e) (uncolor-edge! e)) (edges g))
	#false)))

(define-method (breath-first-search (g <graph>)
				    source
				    (visit-vertex!  <procedure>)
				    (visit-edge!    <procedure>)
				    (order-vertices <procedure>))
  (define (is-marked? v) (atribute? g v #:marked))
  (define (mark! v) (add-atribute! g v #:marked #true))
  (define q (make-q))
  (mark! source)
  (visit-vertex! source)
  (enq! q source)
  (while (not (q-empty? q))
    (let ((v (deq! q)))
      (for-each (lambda (u)
		   (mark! u)
		   (visit-vertex! u)
		   (enq! q u)
		   (visit-edge! v u))
		(order-vertices (remove is-marked? (adjacent g v))))))
  (remove-vertices-atribute! g #:marked))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; SPANNING TREE DFS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define-method (run-spanning-tree-dfs (g <undirected-graph>) root)
  (spanning-tree-dfs g root))

(define-method (spanning-tree-dfs (g <undirected-graph>) root)
  (define tree   (make <undirected-graph>))
  (depth-first-search g root
		      (lambda (v)
			 (color-vertex! v #:green)
			 (wait! "Vertex " (obj->string v) " added to spanning tree.")
			 (add-vertex! tree v))
		      (lambda (u v)
			 (color-edge! (list u v) #:green)
			 (wait! "Edge " (obj->string (list u v)) " added to spanning tree.")
			 (add-edge! tree (list u v)))
		      (lambda (lst)
			 (sort lst <)))
  (if (= (length (vertices g)) (length (vertices tree)))
      (begin
	(show-message! "Spanning Tree obtained")
	(wait! "Clean graph")
	(for-each (lambda (v) (uncolor-vertex! v)) (vertices g))
	(for-each (lambda (e) (uncolor-edge! e)) (edges g))
	tree)
      (begin
	(show-message! "The graph doesn't have a spanning tree")
	(wait! "Clean graph")
	(for-each (lambda (v) (uncolor-vertex! v)) (vertices g))
	(for-each (lambda (e) (uncolor-edge! e)) (edges g))
	#false)))

(define-method (depth-first-search (g <graph>)
				   source
				   (visit-vertex!  <procedure>)
				   (visit-edge!    <procedure>)
				   (order-vertices <procedure>))
  (define (is-marked? v) (atribute? g v #:marked))
  (define (mark! v) (add-atribute! g v #:marked #true))
  (define (search-from v)
    (mark! v)
    (visit-vertex! v)
    (for-each (lambda (u)
		 (unless (is-marked? u)
		   (visit-edge! v u)
		   (search-from u)))
	      (order-vertices (adjacent g v))))
  (search-from source)
  (remove-vertices-atribute! g #:marked))

;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; HEAP DATA STRUCTURE
;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define-class <heap> ()
  (order-pred #:getter heap-pred      #:setter set-heap-pred!     #:init-keyword #:order)
  (get-key    #:getter heap-key-proc  #:setter heap-set-key-proc! #:init-keyword #:key)
  (length     #:getter heap-length    #:setter heap-set-length!   #:init-keyword #:length)
  (array      #:getter heap-array     #:setter heap-set-array!    #:init-keyword #:array)
  (index      #:getter heap-index     #:setter heap-set-index!    #:init-keyword #:index))

(define (parent idx)
  (floor (/ (- idx 1) 2)))

(define (left-child idx)
  (+ (* 2 idx) 1))

(define (right-child idx)
  (* 2 (+ idx 1)))

(define-method (heap-ref heap idx)
  (vector-ref (heap-array heap) idx))

(define (heap-set! heap idx elm)
  (vector-set! (heap-array heap) idx elm))

(define (swap! v i j)
  (define e (vector-ref v i))
  (vector-set! v i (vector-ref v j))
  (vector-set! v j e))

(define (heapify-down! heap idx)
  (define (get-key i)
    ((heap-key-proc heap) (heap-ref heap i)))
  (define pred (heap-pred heap))
  (define l (left-child idx))
  (define r (right-child idx))
  (define p
    (cond ((and (<= l (heap-index heap))
		(pred (get-key l) (get-key idx))
		(if (<= r (heap-index heap))
		    (pred (get-key l) (get-key r))
		    #true)) l)
	  ((and (<= r (heap-index heap))
		(pred (get-key r) (get-key idx))
		(pred (get-key r) (get-key l))) r)
	  (else idx)))
  (unless (equal? p idx)
    (swap! (heap-array heap) idx p)
    (heapify-down! heap p)))

(define (heapify-up! heap idx)
  (define (get-key i)
    ((heap-key-proc heap) (heap-ref heap i)))
  (define pred (heap-pred heap))
  (define i idx)
  (while (and (> i 0)
	      (pred (get-key i) (get-key (parent i))))
    (swap! (heap-array heap) i (parent i))
    (set! i (parent i))))

(define (resize heap)
  (define (vector-new-from source new-size)
    (define (copy-elms from to i)
      (cond ((< i (vector-length from))
	     (vector-set! to i (vector-ref from i))
	     (copy-elms from to (+ i 1)))
	    (else to)))
    (copy-elms source (make-vector new-size '()) 0))
  (let ((size (inexact->exact (expt 2 (+ (/ (log (heap-length heap))
					    (log 2)) 1))))
	(array (heap-array heap)))
    (heap-set-array! heap (vector-new-from array size))
    (heap-set-length! heap size)))

(define-method (make-heap get-key comparator)
  (make <heap>
    #:order  comparator
    #:key    get-key
    #:length 64
    #:array (make-vector 64 null)
    #:index -1))

(define-method (heap? (heap <heap>)) #true)
(define-method (heap? obj)           #false)

(define-method (empty? (heap <heap>))
  (= (heap-index heap) -1))

(define-method (purge! (heap <heap>))
  (heap-set-index! heap -1)
  (heap-set-array! heap (make-vector (heap-length heap) null)))

(define-method (heap-size heap)
  (+ (heap-index heap) 1))

(define-method (priority (heap <heap>))
  (cond ((empty? heap)
	 (error "the heap is empty"))
	(else
	 (heap-ref heap 0))))

(define-method (dequeue! (heap <heap>))
  (cond ((empty? heap)
	 (error "the heap is empty"))
	(else
	 (let ((p (heap-ref heap 0)))
	   (heap-set! heap 0 (heap-ref heap (heap-index heap)))
	   (heap-set! heap (heap-index heap) null)
	   (heap-set-index! heap (- (heap-index heap) 1))
	   (heapify-down! heap 0)
	   p))))

(define-method (enqueue! (heap <heap>) elm)
  (when (= (+ (heap-size heap) 1)
	   (heap-length heap))
    (resize heap))
  (heap-set-index! heap (+ (heap-index heap) 1))
  (heap-set! heap (heap-index heap) elm)
  (heapify-up! heap (heap-index heap)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; MINIMUM SPANNING TREE PRIM
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define-method (run-prim (g <undirected-graph>) root)
  (prim g root #:weight))

(define-method (prim (g <undirected-graph>) root (symb <keyword>))
  (define (tree-weight tree)
    (apply + (map weight (edges tree))))
  (define (weight? x)   (atribute? g x symb))
  (define (marked? x)   (atribute? g x #:mark))
  (define (weight x)    (value (atribute g x symb)))
  (define (mark! x)     (add-atribute! g x #:mark #t))
  (define tree   (make <undirected-graph>))
  (define queue  (make-heap weight <=))
  (color-vertex! root #:green)
  (wait! "Vertex " (obj->string root) " added to minimum spanning tree.")
  (mark! root)
  (add-vertex! tree root)
  (for-each (lambda (v)
	       (enqueue! queue (list root v)))
	    (adjacent g root))
  (while (not (empty? queue))
    (let* ((edge (dequeue! queue))
	   (u    (from edge))
	   (v    (to edge)))
      (unless (marked? v)
	(color-vertex! v #:green)
	(wait! "Vertex " (obj->string v) " added to minimum spanning tree.")
	(mark! v)
	(add-vertex! tree v)
	(color-edge! edge #:red)
	(wait! "Edge " (obj->string edge) " added to minimum spanning tree.")
	(add-edge! tree edge)
	(add-atribute! tree edge symb (weight edge))
	(for-each (lambda (w)
		     (enqueue! queue (list v w)))
		  (remove marked? (adjacent g v))))))
  (remove-vertices-atribute! g #:mark)
  (if (= (length (vertices g))
	 (length (vertices tree)))
      (begin
	(show-message! "Minimum Spanning Tree obtained\n\nTree weight = " (obj->string (tree-weight tree)))
	(wait! "Clean graph")
	(for-each (lambda (v) (uncolor-vertex! v)) (vertices g))
	(for-each (lambda (e) (uncolor-edge! e)) (edges g))
	tree)
      (begin
	(show-message! "The graph doesn't have a minimum spanning tree")
	(wait! "Clean graph")
	(for-each (lambda (v) (uncolor-vertex! v)) (vertices g))
	(for-each (lambda (e) (uncolor-edge! e)) (edges g))
	#false)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; MINIMUM SPANNING FOREST KRUSKAL
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define-method (run-kruskal (g <undirected-graph>))
  (kruskal g #:weight))

(define-method (kruskal (g <undirected-graph>) (symb <keyword>))
  (define (kruskal-message)
    (define weights (make-hash-table))
    (define message "")
    (for-each (lambda (e)
		(when (marked? e)
		  (hash-set! weights (mark e) (+ (weight e)
						 (if (hash-ref weights (mark e)) (hash-ref weights (mark e)) 0)))))
	      (edges g))
    (hash-for-each (lambda (k v)
		     (set! message (string-append message
						  "  peso marca " (obj->string k) " = " (obj->string v) "\n")))
		   weights)
    message)
  (define (color-kruskal! v colors)
    (let ((col (hash-ref colors (mark v))))
      (label-vertex! v (obj->string (mark v)))
      (cpp-color-node-label! v (first col) (second col) (third col) 150)
      (cpp-color-node! v (first col) (second col) (third col) 150)))
  (define (color-edge-kruskal! e colors)
    (let ((from-col (hash-ref colors (mark (from e))))
	  (to-col (hash-ref colors (mark (to e)))))
      (cpp-color-edge! (from e) (to e) (first to-col) (second to-col) (third to-col) 150)))
  (define (weight? x)   (atribute? g x symb))
  (define (marked? x)   (atribute? g x #:mark))
  (define (weight x)    (value (atribute g x symb)))
  (define (mark x)      (value (atribute g x #:mark)))
  (define (mark! x k)   (add-atribute! g x #:mark k))
  (define (propagate-mark old new colors)
    (for-each (lambda (v)
		 (mark! v new)
		 (color-kruskal! v colors))
	      (filter (lambda (v) (and (marked? v) (equal? (mark v) old))) (vertices g)))
    (for-each (lambda (e)
		(mark! e new)
		(color-edge-kruskal! e colors))
	      (filter (lambda (e) (and (marked? e) (equal? (mark e) old))) (edges g))))
  (define colors (make-hash-table))
  (define tree (make <undirected-graph>))
  (define queue (make-heap weight <=))
  (define visited-edges 0)
  (define component-id 0)
  (define num-edges-tree (- (length (vertices g)) 1))
  (hash-set! colors component-id (list (random 256) (random 256) (random 256)))
  (for-each (lambda (e)
	       (enqueue! queue e))
	    (edges g))
  (while (and (not (empty? queue))
	      (not (equal? visited-edges num-edges-tree)))
    (let* ((edge (dequeue! queue))
	   (u    (from edge))
	   (v    (to edge)))
      (color-edge! edge #:yellow)
      (wait! "Revisando arista " (obj->string edge))
      (cond ((and (not (marked? u))
		  (not (marked? v)))
	     (mark! u component-id)
	     (color-kruskal! u colors)
	     (add-vertex! tree u)
	     (mark! v component-id)
	     (color-kruskal! v colors)
	     (add-vertex! tree v)
	     (mark! edge component-id)
	     (color-edge-kruskal! edge colors)
	     (add-edge! tree edge)
	     (set! visited-edges (+ visited-edges 1))
	     (set! component-id (+ component-id 1))
	     (hash-set! colors component-id (list (random 256) (random 256) (random 256))))
	    ((and (marked? u)
		  (not (marked? v)))
	     (mark! v (mark u))
	     (color-kruskal! v colors)
	     (add-vertex! tree v)
	     (mark! edge (mark u))
	     (color-edge-kruskal! edge colors)
	     (add-edge! tree edge)
	     (set! visited-edges (+ visited-edges 1)))
	    ((and (not (marked? u))
		  (marked? v))
	     (mark! u (mark v))
	     (color-kruskal! u colors)
	     (add-vertex! tree u)
	     (mark! edge (mark v))
	     (color-edge-kruskal! edge colors)
	     (add-edge! tree edge)
	     (set! visited-edges (+ visited-edges 1)))
	    ((and (marked? u)
		  (marked? v)
		  (not (equal? (mark u) (mark v))))
	     (mark! edge (mark v))
	     (color-edge-kruskal! edge colors)
	     (add-edge! tree edge)
	     (propagate-mark (mark u) (mark v) colors)
	     (set! visited-edges (+ visited-edges 1))))))
  (let ((message (string-append "Los árboles de mínima expansión han sido encontrados\n\n" (kruskal-message))))
    (show-message! message))
  (wait!)
  (remove-vertices-atribute! g #:mark)
  (remove-edges-atribute! g #:mark)
  tree)

;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; SHORTEST PATH GENERAL DIJKSTRA
;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define-method (run-dijkstra (g <directed-graph>) origin destination)
  (dijkstra g origin destination #:distance))

(define-method (dijkstra (g <directed-graph>)
			 origin
			 destination
			 (symb <keyword>))
  (define (mark? x)          (atribute? g x #:mark))
  (define (distance x)       (value (atribute g x #:distance)))
  (define (predecessor x)    (value (atribute g x #:predecessor)))
  (define (mark x)           (value (atribute g x #:mark)))
  (define (weight x)         (value (atribute g x symb)))
  (define (distance! x v)    (add-atribute! g x #:distance v))
  (define (predecessor! x v) (add-atribute! g x #:predecessor v))
  (define (mark! x v)        (add-atribute! g x #:mark v))
  (define (-mark! x)         (remove-atribute! g x #:mark))

  (define (better-path? u->v)
    (define u (from u->v))
    (define v (to u->v))
    (< (+ (distance u)
	  (weight u->v))
       (distance v)))
  
  (define (update-paths! u)
    (define vs (filter (lambda (x) (equal? (predecessor x) u)) (out-adjacent g u)))
    (unless (null? vs)
      (let ((v (first vs)))
	(predecessor! v u)
	(distance! v (+ (distance u) (weight (list u v))))
	(dijkstra-label! v)
	(update-paths! v))))

  (define (cons-path)
    (define (acumulate arrow path)
      (let ((u (from arrow)) (v (to arrow)))
	(cond ((equal? u origin) (cons (list origin v) path))
	      (else              (acumulate (list (predecessor u) u) (cons arrow path))))))
    (acumulate (list (predecessor destination) destination) '()))

  (define (form-negative-cycle new-arrow)
    (define (acumulate arrow cycle weights)
      (let ((u (from arrow)) (v (to arrow)))
	(cond ((equal? u (to new-arrow))
	       (if (< (+ (weight arrow) (apply + weights)) 0)
		   (cons arrow cycle)
		   #false))
	      ((equal? u origin)
	       #false)
	      (else
	       (acumulate (list (predecessor u) u) (cons arrow cycle) (cons (weight arrow) weights))))))
    (acumulate new-arrow null null))

  (define (dijkstra-label! v)
    (label-vertex! v (string-append "[" (obj->string (predecessor v)) "," (obj->string (distance v)) "]")))

  (define vertex-queue (make-heap distance <=))
  (define arrow-queue  (make-heap weight <=))
  (define neg-cycl     #false)

  (wait! "Inicia el dijkstra sencillo")
  (for-each (lambda (v)
	       (predecessor! v v)
	       (distance! v (inf))
	       (dijkstra-label! v))
	    (vertices g))
  (predecessor! origin origin)
  (distance! origin 0)
  (dijkstra-label! origin)
  (color-vertex! origin #:yellow)
  (wait! "Se marca " (obj->string origin) " de manera temporal")
  (mark! origin 'temporal)
  (enqueue! vertex-queue origin)
  (while (not (empty? vertex-queue))
    (let ((v (dequeue! vertex-queue)))
      (color-vertex! v #:red)
      (wait! "Se marca " (obj->string v) " de manera definitiva")
      (mark! v 'final)
      (unless (equal? v (predecessor v))
	(color-arrow! (list (predecessor v) v) #:yellow)
	(wait! "Se visita " (obj->string (list (predecessor v) v)))
	(mark! (list (predecessor v) v) 'touched))
      (for-each (lambda (k)
		   (cond ((not (mark? k))
			  (color-vertex! k #:yellow)
			  (mark! k 'temporal)
			  (predecessor! k v)
			  (distance! k (+ (distance v) (weight (list v k))))
			  (dijkstra-label! k)
			  (enqueue! vertex-queue k)
			  (wait! "Se marca " (obj->string k) " de manera temporal"))
			 ((and (equal? (mark k) 'temporal)
			       (< (+ (distance v) (weight (list v k)))
				  (distance k)))
			  (predecessor! k v)
			  (distance! k (+ (distance v) (weight (list v k))))
			  (dijkstra-label! k)
			  (wait! "Mejora ruta " (obj->string k)))))
		(out-adjacent g v))))
  (cond ((mark? destination)
	 (wait! "Inicia el dijkstra general")
	 (for-each (lambda (a)
		      (enqueue! arrow-queue a))
		   (filter (lambda (a) (not (mark? a))) (arrows g)))
	 (while (not (empty? arrow-queue))
	   (let* ((u->v  (dequeue! arrow-queue))
		  (u     (from u->v))
		  (v     (to u->v))
		  (cycle (form-negative-cycle u->v)))
	     (color-arrow! u->v #:green)
	     (wait! "Se revisa si " (obj->string u->v) " mejora la ruta sin formar ciclos negativos")
	     (cond ((and (better-path? u->v)
			 (not cycle))
		    (color-arrow! u->v #:yellow)
		    (wait! "El arco " (obj->string u->v) " si mejora la ruta y no forma ciclos negativos")
		    (uncolor-arrow! (list (predecessor v) v))
		    (enqueue! arrow-queue (list (predecessor v) v))
		    (color-arrow! u->v #:yellow)
		    (mark! u->v 'touched)
		    (predecessor! v u)
		    (distance! v (+ (distance u) (weight u->v)))
		    (dijkstra-label! v)
		    (update-paths! v)
		    (wait! "Se actualiza la mejor ruta"))
		   ((list? cycle)
		    (color-arrow! u->v #:red)
		    (wait! "El arco " (obj->string u->v) " forma un ciclo negativo!")
		    (set! neg-cycl (list #:negative-cycle cycle (apply + (map weight cycle))))
		    (purge! arrow-queue))
		   (else
		    (wait! "El arco " (obj->string u->v) " no mejora la ruta")
		    (uncolor-arrow! u->v)))))
	 (let ((return (if (not neg-cycl) (cons-path) neg-cycl)))
	   (remove-vertices-atribute! g #:predecessor)
	   (remove-vertices-atribute! g #:mark)
	   (remove-arrows-atribute! g #:mark)
	   (for-each (lambda (v) (label-vertex! v "")) (vertices g))
	   (if neg-cycl
	       (begin (show-message! (string-append "Se forma el ciclo negativo = " (obj->string (cadr neg-cycl))
						    "\n\n el cual reduce la ruta en " (obj->string (caddr neg-cycl))
						    " cada vez que se recorre."))
		      (remove-vertices-atribute! g #:distance))
	       (begin (show-message! (string-append "Se ha encontrado la ruta mas corta = " (obj->string return)
						    "\n\n la cual tiene una distancia de " (obj->string (distance destination))))
		      (remove-vertices-atribute! g #:distance)))
	   return))
	(else
	 (remove-vertices-atribute! g #:predecessor)
	 (remove-vertices-atribute! g #:distance)
	 (remove-vertices-atribute! g #:mark)
	 (remove-arrows-atribute! g #:mark)
	 (for-each (lambda (v) (label-vertex! v "")) (vertices g))
	 (show-message! "No existe una trayectoria de " (obj->string origin) " a " (obj->string destination))
	 (list #:no-path))))


;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; ALL SHORTESTS PATHS FLOYD WARSHALL
;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (floyd-warshall-results paths)
  (for-each (lambda (path)
	      (let ((origin (first (first path)))
		    (destination (last (last path))))
		(show-message! "Mostrando la ruta mas corta de "
			       (obj->string origin) " a "
			       (obj->string destination)
			       " con distancia de "
			       (obj->string (apply + (map (lambda (e) (value (atribute G e #:distance))) path))))
		(for-each (lambda (arrow)
			    (color-arrow! arrow #:blue))
			  path)
		(wait!)
		(for-each (lambda (arrow)
			    (uncolor-arrow! arrow))
			  path)))
	    paths))

(define-method (run-floyd-warshall (g <directed-graph>))
  (let ((result (floyd-warshall g #:distance)))
    (if (equal? (first result) #:negative-cycle)
	(show-message! "Se forma el ciclo negativo = " (obj->string (second result))
			       "\n\n el cual reduce la ruta en " (obj->string (third result)))
	(floyd-warshall-results result))))

(define-method (floyd-warshall (G <directed-graph>)
			       (symb  <keyword>))
  (define (distance-matrix G)
    (define n (length (vertices G)))
    (define M (vector-map (lambda (i x) (make-vector n (inf))) (make-vector n)))
    (for-each (lambda (x) (vector-set! (vector-ref M x) x 0)) (iota n))
    (for-each (lambda (a) (let ((u (from a)) (v (to   a))) (vector-set! (vector-ref M (assoc-ref v:i u))
								   (assoc-ref v:i v)
								   (value (atribute G a symb)))))
	      (arrows G))
    (lambda (i j . v)
      (cond ((null? v)
	     (vector-ref (vector-ref M i) j))
	    (else
	     (vector-set! (vector-ref M i) j (first v))))))
  (define (predecessor-matrix G)
    (define n (length (vertices G)))
    (define M (vector-map (lambda (i x) (make-vector n null)) (make-vector n)))
    (for-each (lambda (x) (vector-set! (vector-ref M x) x (assoc-ref i:v x))) (iota n))
    (for-each (lambda (a) (let ((u (from a)) (v (to   a)))
		       (vector-set! (vector-ref M (assoc-ref v:i u)) (assoc-ref v:i v) u)))
	      (arrows G))
    (lambda (i j . v)
      (cond ((null? v)
	     (vector-ref (vector-ref M i) j))
	    (else
	     (vector-set! (vector-ref M i) j (first v))))))
  (define (path? obj)
    (list? obj))
  (define (acumulate-path D PI u v path)
    (define (acumulate D PI u v path)
      (cond ((= u v) (cons (assoc-ref i:v v) path))
	  ((null? (PI u v)) null)
	  (else (acumulate D PI u (assoc-ref v:i (PI u v)) (cons (assoc-ref i:v v) path)))))
    (let ((p (acumulate D PI u v path)))
      (if (null? p) null (map (lambda (u v) (list u v)) p (cdr p)))))
  (define (cons-neg-cyc D PI i j)
    (let ((path (acumulate-path D PI i (assoc-ref v:i (PI i j)) (cons (assoc-ref i:v i) null))))
      (list #:negative-cycle path
	    (apply + (map (lambda (a) (value (atribute G a symb))) path)))))
  (define (path-weight D PI path)
    (D (assoc-ref v:i (first path))
       (assoc-ref v:i (last path))))
  (define (cons-all-paths D PI)
    (remove null? (apply append (map (lambda (u) (map (lambda (v) (acumulate-path D PI u v '())) (iota n))) (iota n)))))
  (define n  (length (vertices G)))
  (define i:v (map (lambda (i v) (cons i v)) (iota n) (vertices G)))
  (define v:i (map (lambda (i v) (cons v i)) (iota n) (vertices G)))
  (define D  (distance-matrix G))
  (define PI (predecessor-matrix G))
  (define neg-cyc #false)
  (for-each
   (lambda (k)
      (for-each
       (lambda (i)
	  (for-each
	   (lambda (j)
	      (let ((new-dist (+ (D i k) (D k j)))
		    (new-pred (PI k j)))
		(when (> (D i j) new-dist)
		  (D  i j new-dist)
		  (PI i j new-pred)
		  (when (and (not (path? neg-cyc)) (= i j) (negative? (D i j)))
		    (set! neg-cyc (cons-neg-cyc D PI i j))))))
	   (iota n)))
       (iota n)))
   (iota n))
  (if (path? neg-cyc)
      neg-cyc
      (cons-all-paths D PI)))

;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; MAXIMUM FLOW FORD FULKERSON
;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define-method (graph-copy (g <directed-graph>))
  (define g* (make <directed-graph>))
  (for-each (lambda (v)
	      (add-vertex! g* v)
	      (for-each (lambda (atribute)
			  (add-atribute! g* v (car atribute) (cdr atribute)))
			(atributes g v)))
	    (vertices g))
  (for-each (lambda (a)
	      (add-arrow! g* a)
	      (for-each (lambda (atribute)
			  (add-atribute! g* a (car atribute) (cdr atribute)))
			(atributes g a)))
	    (arrows g))
  g*)

(define-method (run-ford-fulkerson (g <directed-graph>) (sources <list>) (sinks <list>) . constant)
  (define (flow h)
    (- (apply + (map (lambda (s) (apply + (map (lambda (a) (value (atribute h a #:flow))) (outcident h s)))) sources))
       (apply + (map (lambda (s) (apply + (map (lambda (a) (value (atribute h a #:flow))) (incident h s)))) sources))))
  (define g* (graph-copy g))
  (define fmax #true)
  (if (null? constant)
      (ford-fulkerson! g* sources sinks)
      (ford-fulkerson! g* sources sinks constant))
  (for-each (lambda (v) (color-vertex! v #:red)) sources)
  (for-each (lambda (v) (color-vertex! v #:green)) sinks)
  (set! fmax (apply max (map (lambda (a) (value (atribute g* a #:flow))) (arrows g*))))
  (show-message! "Se encontró el flujo!\n\n"
		 "fuentes = " (obj->string sources) "\n"
		 "sumideros = " (obj->string sinks) "\n\n"
		 "flujo en la red = " (obj->string (flow g*)))
  (for-each (lambda (a)
	      (let ((f (value (atribute g* a #:flow))))
		(label-arrow! a (string-append (obj->string (value (atribute g* a #:q-min))) ","
					       (obj->string (value (atribute g* a #:q-max))) ",f:"
					       (obj->string f)))
		(when (not (zero? f))
		  (cpp-color-arrow! (from a) (to a) 0 135 189
				    (truncate (inexact->exact (* 150 (/ (value (atribute g* a #:flow)) fmax)))))
		  )))
	    (arrows g*)))

(define-method (ford-fulkerson! (g <directed-graph>)
				(sources <list>)
				(sinks <list>) .
				constant)
  ;; atribute predicates
  (define (direction? x)   (atribute? g x #:direction))
  (define (previous? x)    (atribute? g x #:previous))
  (define (flow? x)        (atribute? g x #:flow))
  (define (examined? x)    (atribute? g x #:examined))
  (define (q-min? x)       (atribute? g x #:q-min))
  (define (q-max? x)       (atribute? g x #:q-max))
  (define (old-q-min? x)   (atribute? g x #:old-q-min))
  
  ;; atribute selectors
  (define (direction x)    (value (atribute g x #:direction)))
  (define (previous x)     (value (atribute g x #:previous)))
  (define (flow x)         (value (atribute g x #:flow)))
  (define (examined x)     (value (atribute g x #:examined)))
  (define (clon x)         (value (atribute g x #:clon)))
  (define (q-min x)        (value (atribute g x #:q-min)))
  (define (q-max x)        (value (atribute g x #:q-max)))
  (define (old-q-min x)    (value (atribute g x #:old-q-min)))
  
  ;; atribute mutators
  (define (direction! x d) (add-atribute! g x #:direction d))
  (define (previous! x d)  (add-atribute! g x #:previous d))
  (define (flow! x d)      (add-atribute! g x #:flow d))
  (define (examined! x d)  (add-atribute! g x #:examined d))
  (define (clon! x d)      (add-atribute! g x #:clon d))
  (define (q-min! x d)     (add-atribute! g x #:q-min d))
  (define (q-max! x d)     (add-atribute! g x #:q-max d))
  (define (old-q-min! x d) (add-atribute! g x #:old-q-min d))
  (define (-direction! x)  (remove-atribute! g x #:direction))
  (define (-previous! x)   (remove-atribute! g x #:previous))
  (define (-flow! x)       (remove-atribute! g x #:flow))
  (define (-examined! x)   (remove-atribute! g x #:examined))
  (define (-clon! x)       (remove-atribute! g x #:clon))
  (define (-q-min! x)      (remove-atribute! g x #:q-min))
  (define (-q-max! x)      (remove-atribute! g x #:q-max))
  (define (-old-q-min! x)  (remove-atribute! g x #:old-q-min))
  
  ;; algorithm procedures
  (define (initialize-atributes!)
    (for-each (lambda (a) (unless (q-min? a) (q-min! a 0)) (flow! a 0))
	      (arrows g)))

  (define (destroy-atributes!*)
    (for-each (lambda (v) (-direction! v) (-previous! v) (-examined! v))
	      (vertices g)))
  
  (define (destroy-atributes!)
    (for-each (lambda (v) (-direction! v) (-previous! v) (-flow! v) (-examined! v))
	      (vertices g)))
  
  (define (morph-multiple-sources! x)
    (add-vertex! g x)
    (for-each (lambda (v)
		 (let ((a (list x v)))
		   (add-arrow! g a)
		   (q-max! a (inf)) (flow! a 0) (q-min! a 0)))
	      sources))
  
  (define (recover-multiple-sources! x)
    (remove-vertex! g x))
  
  (define (morph-multiple-sinks! x)
    (define pre-x (string-append "pre-" (obj->string x)))
    (add-vertex! g pre-x)
    (for-each (lambda (v)
		 (let ((a (list v pre-x)))
		   (add-arrow! g a)
		   (q-max! a (inf)) (flow! a 0) (q-min! a 0)))
	      sinks)
    (add-vertex! g x)
    (let ((a (list pre-x x)))
      (add-arrow! g a)
      (q-max! a (if (null? constant) (inf) (first constant)))
      (flow! a 0) (q-min! a 0)))
  
  (define (recover-multiple-sinks! x)
    (remove-vertex! g x)
    (remove-vertex! g (string-append "pre-" (obj->string x))))
  
  (define (morph-restricted-vertices!)
    (define (restricted? v) (or (q-min? v) (q-max? v)))
    (define clon-v    null)
    (define v->clon-v null)
    (define clon-v->j null)
    (for-each (lambda (v)
		 (set! clon-v    (string-append "clon-" (obj->string v)))
		 (set! v->clon-v (list v clon-v))
		 (add-vertex! g clon-v)
		 (clon! v clon-v)
		 (add-arrow! g v->clon-v)
		 (q-min! v->clon-v (if (q-min? v) (q-min v) 0))
		 (q-max! v->clon-v (if (q-max? v) (q-max v) (inf)))
		 (flow! v->clon-v 0)
		 (for-each (lambda (j)
			      (set! clon-v->j (list clon-v j))
			      (add-arrow! g clon-v->j)
			      (let ((a (list v j)))
				(q-min! clon-v->j (q-min a))
				(q-max! clon-v->j (q-max a))
				(flow!  clon-v->j (flow  a))
				(remove-arrow! g a)))
			   (remove (lambda (u) (equal? u clon-v)) (out-adjacent g v))))
	      (filter restricted? (vertices g))))
  
  (define (recover-restricted-vertices!)
    (define (restricted? v) (or (q-min? v) (q-max? v)))
    (define clon-v null)
    (for-each (lambda (v)
		 (set! clon-v (clon v))
		 (for-each (lambda (j)
			      (let ((a1 (list v j))
				    (a2 (list clon-v j)))
				(add-arrow! g a1)
				(q-min! a1 (q-min a2))
				(q-max! a1 (q-max a2))
				(flow!  a1 (flow  a2))))
			   (out-adjacent g (clon v)))
		 (remove-vertex! g clon-v)
		 (-clon! v))
	      (filter restricted? (vertices g))))
  
  (define (morph-restricted-arrows! x y x* y*)
    (define (add-arrow+atrb! a qmax flw qmin)
      (add-arrow! g a)
      (q-max! a qmax) (flow! a flw) (q-min! a qmin))
    (add-vertices! g (list x* y*))
    (for-each (lambda (a)
		 (let ((a1 (list x* (to a)))
		       (a2 (list (from a) y*)))
		   (if (arrow? g a1)
		       (q-max! a1 (+ (q-min a) (q-max a1)))
		       (add-arrow+atrb! a1 (q-min a) 0 0))
		   (if (arrow? g a2)
		       (q-max! a2 (+ (q-min a) (q-max a2)))
		       (add-arrow+atrb! a2 (q-min a) 0 0))
		   (old-q-min! a (q-min a))
		   (q-max! a (- (q-max a) (q-min a)))
		   (q-min! a 0)))
	      (remove (lambda (a) (zero? (q-min a))) (arrows g)))
    (add-arrow+atrb! (list x y) (inf) 0 0)
    (add-arrow+atrb! (list y x) (inf) 0 0))
  
  (define (recover-restricted-arrows! x y x* y*)
    (remove-arrows! g (list (list x y) (list y x)))
    (for-each (lambda (a)
		(flow!  a (+ (flow a) (old-q-min a)))
		(q-max! a (+ (q-max a) (old-q-min a)))
		(q-min! a (old-q-min a))
		(-old-q-min! a))
	      (filter (lambda (a) (old-q-min? a)) (arrows g)))
    (remove-vertices! g (list x* y*)))

  (define (label! v dir pre flw)
    (direction! v dir)
    (previous!  v pre)
    (flow!      v flw))

  (define (labeled? v)
    (and (direction? v) (previous? v) (flow? v)))

  (define (all-examined?)
    (fold (lambda (x y) (and x y)) #true (map examined? (filter labeled? (vertices g)))))

  (define (examine! v)
    (for-each (lambda (u)
		 (let ((a (list v u)))
		   (when (< (flow a) (q-max a))
		     (label! u '+ v (min (flow v) (- (q-max a) (flow a)))))))
	      (remove (lambda (u) (labeled? u)) (out-adjacent g v)))
    (for-each (lambda (u)
		 (let ((a (list u v)))
		   (when (> (flow a) (q-min a))
		     (label! u '- v (min (flow v) (- (flow a) (q-min a)))))))
	      (remove (lambda (u) (labeled? u)) (in-adjacent g v)))
    (examined! v #true))

  (define (augment-flow! x y)
    (define z y)
    (while (not (equal? z x))
      (let ((p (previous z)))
	(if (equal? (direction z) '+)
	    (flow! (list p z) (+ (flow (list p z)) (flow y)))
	    (flow! (list z p) (- (flow (list z p)) (flow y))))
	(set! z p)))
    (destroy-atributes!)
    (find-augmenting-path! x y))
  
  (define (find-augmenting-path! x y)
    (label! x '+ x (inf))
    (while (and (not (all-examined?)) (not (labeled? y)))
      (examine! (first (filter (lambda (v) (and (not (examined? v)) (labeled? v))) (vertices g)))))
    (when (labeled? y)
      (augment-flow! x y)))
  
  ;; Algorithm
  (initialize-atributes!)
  (morph-multiple-sources! 'α)
  (morph-multiple-sinks! 'omega)
  (morph-restricted-vertices!)
  (morph-restricted-arrows! 'α 'omega 'α* 'omega*)
  (find-augmenting-path! 'α* 'omega*)
  (destroy-atributes!*)
  (recover-restricted-arrows! 'α 'omega 'α* 'omega*)
  (find-augmenting-path! 'α 'omega)
  (recover-restricted-vertices!)
  (recover-multiple-sources! 'α)
  (recover-multiple-sinks! 'omega)
  (destroy-atributes!))

;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; MINIMUM COST CONSTANT FLOW (NEGATIVE CYCLES)
;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define-method (run-minimum-cost-constant-flow-nc (g <directed-graph>)
						 (sources <list>)
						 (sinks <list>)
						 constant)
  (define g* (graph-copy g))
  (define F (minimum-cost-negative-cycles g* sources sinks constant))
  (define fmax (apply max (map cdr F)))
  (define total-flow (- (apply + (map cdr (filter (lambda (a:f) (if (member (car (car a:f)) sources) #true #false)) F)))
			(apply + (map cdr (filter (lambda (a:f) (if (member (cadr (car a:f)) sources) #true #false)) F)))))
  (define total-cost (apply + (map (lambda (a:f) (* (cdr a:f) (value (atribute g* (car a:f) #:cost)))) F)))
  (for-each (lambda (v) (color-vertex! v #:red)) sources)
  (for-each (lambda (v) (color-vertex! v #:green)) sinks)
  (for-each (lambda (a:f)
	      (let ((a (car a:f))
		    (f (cdr a:f)))
		(label-arrow! a (string-append (obj->string (value (atribute g* a #:q-max))) ",$"
					       (obj->string (value (atribute g* a #:cost))) ","
					       "f:" (obj->string f)))
		(when (not (zero? f))
		  (cpp-color-arrow! (from a) (to a) 0 135 189
				    (truncate (inexact->exact (* 150 (/ f fmax)))))))) F)
  (show-message! "Se encontró el flujo a costo mínimo!\n\n"
		 "fuentes = " (obj->string sources) "\n"
		 "sumideros = " (obj->string sinks) "\n\n"
		 "flujo en la red = " (obj->string total-flow) "\n"
		 "costo total = " (obj->string total-cost)))

(define-method (minimum-cost-negative-cycles (g <directed-graph>)
					     (sources <list>)
					     (sinks   <list>)
					     constant)
  ;; atribute predicates
  (define (direction? x)   (atribute? g x #:direction))
  (define (previous? x)    (atribute? g x #:previous))
  (define (flow? x)        (atribute? g x #:flow))
  (define (examined? x)    (atribute? g x #:examined))
  (define (q-min? x)       (atribute? g x #:q-min))
  (define (q-max? x)       (atribute? g x #:q-max))
  (define (old-q-min? x)   (atribute? g x #:old-q-min))
    
  ;; atribute selectors
  (define (direction x)    (value (atribute g x #:direction)))
  (define (previous x)     (value (atribute g x #:previous)))
  (define (flow x)         (value (atribute g x #:flow)))
  (define (clon x)         (value (atribute g x #:clon)))
  (define (q-min x)        (value (atribute g x #:q-min)))
  (define (q-max x)        (value (atribute g x #:q-max)))
  (define (old-q-min x)    (value (atribute g x #:old-q-min)))
  (define (cost x)         (value (atribute g x #:cost)))

  ;; atribute mutators
  (define (direction! x d) (add-atribute! g x #:direction d))
  (define (previous! x d)  (add-atribute! g x #:previous d))
  (define (flow! x d)      (add-atribute! g x #:flow d))
  (define (examined! x d)  (add-atribute! g x #:examined d))
  (define (clon! x d)      (add-atribute! g x #:clon d))
  (define (q-min! x d)     (add-atribute! g x #:q-min d))
  (define (q-max! x d)     (add-atribute! g x #:q-max d))
  (define (old-q-min! x d) (add-atribute! g x #:old-q-min d))
  (define (cost! x d)      (add-atribute! g x #:cost d))

  (define (-direction! x)  (remove-atribute! g x #:direction))
  (define (-previous! x)   (remove-atribute! g x #:previous))
  (define (-flow! x)       (remove-atribute! g x #:flow))
  (define (-examined! x)   (remove-atribute! g x #:examined))
  (define (-clon! x)       (remove-atribute! g x #:clon))
  (define (-q-min! x)      (remove-atribute! g x #:q-min))
  (define (-old-q-min! x)  (remove-atribute! g x #:old-q-min))

  ;; algorithm procedures
  (define (initialize-atributes!)
    (for-each (lambda (a) (unless (q-min? a) (q-min! a 0)) (flow! a 0))
	      (arrows g)))
  
  (define (destroy-atributes!)
    (for-each (lambda (v) (-direction! v) (-previous! v) (-flow! v) (-examined! v))
	      (vertices g)))
  
  (define (morph-multiple-sources! x)
    (add-vertex! g x)
    (for-each (lambda (v)
		 (let ((a (list x v)))
		   (add-arrow! g a)
		   (q-max! a (inf)) (flow! a 0) (q-min! a 0) (cost! a 0)))
	      sources))
  
  (define (recover-multiple-sources! x)
    (remove-vertex! g x))
  
  (define (morph-multiple-sinks! x)
    (define pre-x (string-append "pre-" (obj->string x)))
    (add-vertex! g pre-x)
    (for-each (lambda (v)
		 (let ((a (list v pre-x)))
		   (add-arrow! g a)
		   (q-max! a (inf)) (flow! a 0) (q-min! a 0) (cost! a 0)))
	      sinks)
    (add-vertex! g x)
    (let ((a (list pre-x x)))
      (add-arrow! g a)
      (q-max! a (if (null? constant) (inf) constant))
      (flow! a 0) (q-min! a 0) (cost! a 0)))
  
  (define (recover-multiple-sinks! x)
    (remove-vertex! g x)
    (remove-vertex! g (string-append "pre-" (obj->string x))))
  
  (define (morph-restricted-vertices!)
    (define (restricted? v) (or (q-min? v) (q-max? v)))
    (define clon-v    null)
    (define v->clon-v null)
    (define clon-v->j null)
    (for-each (lambda (v)
		 (set! clon-v    (string-append "clon-" (obj->string v)))
		 (set! v->clon-v (list v clon-v))
		 (add-vertex! g clon-v)
		 (clon! v clon-v)
		 (add-arrow! g v->clon-v)
		 (q-min! v->clon-v (if (q-min? v) (q-min v) 0))
		 (q-max! v->clon-v (if (q-max? v) (q-max v) (inf)))
		 (flow! v->clon-v 0)
		 (cost! v->clon-v 0)
		 (for-each (lambda (j)
			      (set! clon-v->j (list clon-v j))
			      (add-arrow! g clon-v->j)
			      (let ((a (list v j)))
				(q-min! clon-v->j (q-min a))
				(q-max! clon-v->j (q-max a))
				(flow!  clon-v->j (flow  a))
				(cost!  clon-v->j (cost  a))
				(remove-arrow! g a)))
			   (remove (lambda (u) (equal? u clon-v)) (out-adjacent g v))))
	      (filter restricted? (vertices g))))
  
  (define (recover-restricted-vertices!)
    (define (restricted? v) (or (q-min? v) (q-max? v)))
    (define clon-v null)
    (for-each (lambda (v)
		 (set! clon-v (clon v))
		 (for-each (lambda (j)
			      (let ((a1 (list v j))
				    (a2 (list clon-v j)))
				(add-arrow! g a1)
				(q-min! a1 (q-min a2))
				(q-max! a1 (q-max a2))
				(flow!  a1 (flow  a2))
				(cost!  a1 (cost  a2))))
			   (out-adjacent g (clon v)))
		 (remove-vertex! g clon-v)
		 (-clon! v))
	      (filter restricted? (vertices g))))
  
  (define (morph-restricted-arrows! x y x* y*)
    (define (add-arrow+atrb! a qmax flw qmin)
      (add-arrow! g a)
      (q-max! a qmax) (flow! a flw) (q-min! a qmin))
    (add-vertices! g (list x* y*))
    (for-each (lambda (a)
		 (let ((a1 (list x* (to a)))
		       (a2 (list (from a) y*)))
		   (if (arrow? g a1)
		       (q-max! a1 (+ (q-min a) (q-max a1)))
		       (add-arrow+atrb! a1 (q-min a) 0 0))
		   (if (arrow? g a2)
		       (q-max! a2 (+ (q-min a) (q-max a2)))
		       (add-arrow+atrb! a2 (q-min a) 0 0))
		   (old-q-min! a (q-min a))
		   (q-max! a (- (q-max a) (q-min a)))
		   (q-min! a 0)))
	      (remove (lambda (a) (zero? (q-min a))) (arrows g)))
    (add-arrow+atrb! (list x y) (inf) 0 0)
    (add-arrow+atrb! (list y x) (inf) 0 0))
  
  (define (recover-restricted-arrows! x y x* y*)
    (remove-arrows! g (list (list x y) (list y x)))
    (for-each (lambda (a)
		(flow!  a (+ (flow a) (old-q-min a)))
		(q-max! a (+ (q-max a) (old-q-min a)))
		(q-min! a (old-q-min a))
		(-old-q-min! a))
	      (filter (lambda (a) (old-q-min? a)) (arrows g)))
    (remove-vertices! g (list x* y*)))

  (define (label! v dir pre flw)
    (direction! v dir)
    (previous!  v pre)
    (flow!      v flw))

  (define (labeled? v)
    (and (direction? v) (previous? v) (flow? v)))

  (define (all-examined?)
    (fold (lambda (x y) (and x y)) #true (map examined? (filter labeled? (vertices g)))))

  (define (examine! v)
    (for-each (lambda (u)
		 (let ((a (list v u)))
		   (when (< (flow a) (q-max a))
		     (label! u '+ v (min (flow v) (- (q-max a) (flow a)))))))
	      (remove (lambda (u) (labeled? u)) (out-adjacent g v)))
    (for-each (lambda (u)
		 (let ((a (list u v)))
		   (when (> (flow a) (q-min a))
		     (label! u '- v (min (flow v) (- (flow a) (q-min a)))))))
	      (remove (lambda (u) (labeled? u)) (in-adjacent g v)))
    (examined! v #true))

  (define (augment-flow! x y)
    (define z y)
    (while (not (equal? z x))
      (let ((p (previous z)))
	(if (equal? (direction z) '+)
	    (flow! (list p z) (+ (flow (list p z)) (flow y)))
	    (flow! (list z p) (- (flow (list z p)) (flow y))))
	(set! z p)))
    (destroy-atributes!)
    (find-augmenting-path! x y))
  
  (define (find-augmenting-path! x y)
    (label! x '+ x (inf))
    (while (and (not (all-examined?)) (not (labeled? y)))
      (examine! (first (filter (lambda (v) (and (not (examined? v)) (labeled? v))) (vertices g)))))
    (when (labeled? y)
      (augment-flow! x y)))

  (define (residual-g G)
    (define (f N a)    (value (atribute N a #:flow)))
    (define (q N a)    (value (atribute N a #:q-max)))
    (define (r N a)    (value (atribute N a #:q-min)))
    (define (c N a)    (value (atribute N a #:cost)))
    (define (q! N a v) (add-atribute! N a #:q-max v))
    (define (c! N a v) (add-atribute! N a #:cost v))
    (define (A! N a v) (add-atribute! N a #:A v))
    (define Gf (make <directed-graph>))
    (for-each (lambda (i->j)
		 (let ((j->i (reverse i->j)))
		   (when (< (f G i->j) (q G i->j))
		     (add-arrow! Gf i->j)
		     (q! Gf i->j (- (q G i->j) (f G i->j)))
		     (c! Gf i->j (c G i->j))
		     (A! Gf i->j 1))
		   (when (> (f G i->j) (r G i->j))
		     (add-arrow! Gf j->i)
		     (q! Gf j->i (- (f G i->j) (r G i->j)))
		     (c! Gf j->i (- (c G i->j)))
		     (A! Gf j->i 2))))
	      (arrows G))
    Gf)

  (define (negative-cycle? lst)
    (and (not (null? lst)) (equal? #:negative-cycle (first lst))))

  (define (negative-cycle->arrows neg-cyc)
    (define path (second neg-cyc))
    (map (lambda (u v) (list u v)) path (cdr path)))

  (define residual #false)
  (define neg-cycl #false)
  
  ;; Algorithm
  (initialize-atributes!)
  (morph-multiple-sources! 'alpha)
  (morph-multiple-sinks! 'omega)
  (morph-restricted-vertices!)
  (morph-restricted-arrows! 'alpha 'omega 'alpha* 'omega*)
  (find-augmenting-path! 'alpha* 'omega*)
  (destroy-atributes!)
  (recover-restricted-arrows! 'alpha 'omega 'alpha* 'omega*)
  (find-augmenting-path! 'alpha 'omega)
  (set! residual (residual-g g))
  (set! neg-cycl (floyd-warshall residual #:cost))
  (while (negative-cycle? neg-cycl)
    (let* ((cycle-arrows neg-cycl)
	   (d (apply min (map (lambda (a) (value (atribute residual a #:q-max))) cycle-arrows))))
      (for-each (lambda (u->v)
		   (let ((v->u (list (to u->v) (from u->v))))
		     (if (= (value (atribute residual u->v #:A)) 1)
			 (flow! u->v (+ (flow u->v) d))
			 (flow! v->u (- (flow v->u) d)))))
		cycle-arrows))
    (set! residual (residual-g g))
    (set! neg-cycl (floyd-warshall residual #:cost)))
  (recover-restricted-vertices!)
  (recover-multiple-sources! 'alpha)
  (recover-multiple-sinks! 'omega)
  (destroy-atributes!)
  (let ((return (map (lambda (a) (cons a (flow a))) (arrows g))))
    (remove-arrows-atribute! g #:flow)
    return))

;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; MINIMUM COST CONSTANT FLOW (SHORTESTS PATHS)
;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define-method (run-minimum-cost-constant-flow-sp (g <directed-graph>)
						   (sources <list>)
						   (sinks <list>)
						   constant)
  (define g* (graph-copy g))
  (define F (minimum-cost-shortests-paths g* sources sinks constant))
  (define fmax (apply max (map cdr F)))
  (define total-flow (- (apply + (map cdr (filter (lambda (a:f) (if (member (car (car a:f)) sources) #true #false)) F)))
			(apply + (map cdr (filter (lambda (a:f) (if (member (cadr (car a:f)) sources) #true #false)) F)))))
  (define total-cost (apply + (map (lambda (a:f) (* (cdr a:f) (value (atribute g* (car a:f) #:cost)))) F)))
  (for-each (lambda (v) (color-vertex! v #:red)) sources)
  (for-each (lambda (v) (color-vertex! v #:green)) sinks)
  (for-each (lambda (a:f)
	      (let ((a (car a:f))
		    (f (cdr a:f)))
		(label-arrow! a (string-append (obj->string (value (atribute g* a #:q-max))) ",$"
					       (obj->string (value (atribute g* a #:cost))) ","
					       "f:" (obj->string f)))
		(when (not (zero? f))
		  (cpp-color-arrow! (from a) (to a) 0 135 189
				    (truncate (inexact->exact (* 150 (/ f fmax)))))))) F)
  (show-message! "Se encontró el flujo a costo mínimo!\n\n"
		 "fuentes = " (obj->string sources) "\n"
		 "sumideros = " (obj->string sinks) "\n\n"
		 "flujo en la red = " (obj->string total-flow) "\n"
		 "costo total = " (obj->string total-cost)))

(define-method (redijkstra (g <directed-graph>)
			   origin
			   destination
			   (symb <keyword>))
  (define (mark? x)          (atribute? g x #:mark))
  (define (distance x)       (value (atribute g x #:distance)))
  (define (predecessor x)    (value (atribute g x #:predecessor)))
  (define (mark x)           (value (atribute g x #:mark)))
  (define (weight x)         (value (atribute g x symb)))
  (define (distance! x v)    (add-atribute! g x #:distance v))
  (define (predecessor! x v) (add-atribute! g x #:predecessor v))
  (define (mark! x v)        (add-atribute! g x #:mark v))
  (define (-mark! x)         (remove-atribute! g x #:mark))

  (define (better-path? u->v)
    (define u (from u->v))
    (define v (to u->v))
    (< (+ (distance u)
	  (weight u->v))
       (distance v)))
  
  (define (update-paths! u)
    (define vs (filter (lambda (x) (equal? (predecessor x) u)) (out-adjacent g u)))
    (unless (null? vs)
      (let ((v (first vs)))
	(predecessor! v u)
	(distance! v (+ (distance u) (weight (list u v))))
	(update-paths! v))))

  (define (cons-path)
    (define (acumulate arrow path)
      (let ((u (from arrow)) (v (to arrow)))
	(cond ((equal? u origin) (cons (list origin v) path))
	      (else              (acumulate (list (predecessor u) u) (cons arrow path))))))
    (acumulate (list (predecessor destination) destination) '()))

  (define (form-negative-cycle new-arrow)
    (define (acumulate arrow cycle weights)
      (let ((u (from arrow)) (v (to arrow)))
	(cond ((equal? u (to new-arrow))
	       (if (< (+ (weight arrow) (apply + weights)) 0)
		   (cons arrow cycle)
		   #false))
	      ((equal? u origin)
	       #false)
	      (else
	       (acumulate (list (predecessor u) u) (cons arrow cycle) (cons (weight arrow) weights))))))
    (acumulate new-arrow null null))

  (define vertex-queue (make-heap distance <=))
  (define arrow-queue  (make-heap weight <=))
  (define neg-cycl     #false)

  (for-each (lambda (v)
	       (predecessor! v v)
	       (distance! v (inf)))
	    (vertices g))
  (predecessor! origin origin)
  (distance! origin 0)
  (mark! origin 'temporal)
  (enqueue! vertex-queue origin)
  (while (not (empty? vertex-queue))
    (let ((v (dequeue! vertex-queue)))
      (mark! v 'final)
      (unless (equal? v (predecessor v))
	(mark! (list (predecessor v) v) 'touched))
      (for-each (lambda (k)
		   (cond ((not (mark? k))
			  (mark! k 'temporal)
			  (enqueue! vertex-queue k)
			  (predecessor! k v)
			  (distance! k (+ (distance v) (weight (list v k)))))
			 ((and (equal? (mark k) 'temporal)
			       (< (+ (distance v) (weight (list v k)))
				  (distance k)))
			  (predecessor! k v)
			  (distance! k (+ (distance v) (weight (list v k)))))))
		(out-adjacent g v))))
  (cond ((mark? destination)
	 (for-each (lambda (a)
		      (enqueue! arrow-queue a))
		   (filter (lambda (a) (not (mark? a))) (arrows g)))
	 (while (not (empty? arrow-queue))
	   (let* ((u->v  (dequeue! arrow-queue))
		  (u     (from u->v))
		  (v     (to u->v))
		  (cycle (form-negative-cycle u->v)))
	     (cond ((and (better-path? u->v)
			 (not cycle))
		    (enqueue! arrow-queue (list (predecessor v) v))
		    (mark! u->v 'touched)
		    (predecessor! v u)
		    (distance! v (+ (distance u) (weight u->v)))
		    (update-paths! v))
		   ((list? cycle)
		    (set! neg-cycl (list #:negative-cycle cycle (apply + (map weight cycle))))
		    (purge! arrow-queue)))))
	 (let ((return (if (not neg-cycl) (cons-path) neg-cycl)))
	   (remove-vertices-atribute! g #:predecessor)
	   (remove-vertices-atribute! g #:mark)
	   (remove-arrows-atribute! g #:mark)
	   (remove-vertices-atribute! g #:distance)
	   return))
	(else
	 (remove-vertices-atribute! g #:predecessor)
	 (remove-vertices-atribute! g #:distance)
	 (remove-vertices-atribute! g #:mark)
	 (remove-arrows-atribute! g #:mark)
	 (list #:no-path))))

(define-method (minimum-cost-shortests-paths (g <directed-graph>)
					     (sources <list>)
					     (sinks   <list>)
					     constant)
  ;; atribute predicates
  (define (direction? x)   (atribute? g x #:direction))
  (define (previous? x)    (atribute? g x #:previous))
  (define (flow? x)        (atribute? g x #:flow))
  (define (examined? x)    (atribute? g x #:examined))
  (define (q-min? x)       (atribute? g x #:q-min))
  (define (q-max? x)       (atribute? g x #:q-max))
  (define (old-q-min? x)   (atribute? g x #:old-q-min))
  
  ;; atribute selectors
  (define (direction x)    (value (atribute g x #:direction)))
  (define (previous x)     (value (atribute g x #:previous)))
  (define (flow x)         (value (atribute g x #:flow)))
  (define (clon x)         (value (atribute g x #:clon)))
  (define (q-min x)        (value (atribute g x #:q-min)))
  (define (q-max x)        (value (atribute g x #:q-max)))
  (define (old-q-min x)    (value (atribute g x #:old-q-min)))
  (define (cost x)         (value (atribute g x #:cost)))

  ;; atribute mutators
  (define (direction! x d) (add-atribute! g x #:direction d))
  (define (previous! x d)  (add-atribute! g x #:previous d))
  (define (flow! x d)      (add-atribute! g x #:flow d))
  (define (examined! x d)  (add-atribute! g x #:examined d))
  (define (clon! x d)      (add-atribute! g x #:clon d))
  (define (q-min! x d)     (add-atribute! g x #:q-min d))
  (define (q-max! x d)     (add-atribute! g x #:q-max d))
  (define (old-q-min! x d) (add-atribute! g x #:old-q-min d))
  (define (cost! x d)      (add-atribute! g x #:cost d))

  (define (-direction! x)  (remove-atribute! g x #:direction))
  (define (-previous! x)   (remove-atribute! g x #:previous))
  (define (-flow! x)       (remove-atribute! g x #:flow))
  (define (-examined! x)   (remove-atribute! g x #:examined))
  (define (-clon! x)       (remove-atribute! g x #:clon))
  (define (-q-min! x)      (remove-atribute! g x #:q-min))
  (define (-old-q-min! x)  (remove-atribute! g x #:old-q-min))
  
  ;; algorithm procedures
  (define (initialize-atributes!)
    (for-each (lambda (a) (unless (q-min? a) (q-min! a 0)) (flow! a 0))
	      (arrows g)))
  
  (define (destroy-atributes!)
    (for-each (lambda (v) (-direction! v) (-previous! v) (-flow! v) (-examined! v))
	      (vertices g)))
  
  (define (morph-multiple-sources! x)
    (add-vertex! g x)
    (for-each (lambda (v)
		 (let ((a (list x v)))
		   (add-arrow! g a)
		   (q-max! a (inf)) (flow! a 0) (q-min! a 0) (cost! a 0)))
	      sources))
  
  (define (recover-multiple-sources! x)
    (remove-vertex! g x))
  
  (define (morph-multiple-sinks! x)
    (define pre-x (string-append "pre-" (obj->string x)))
    (add-vertex! g pre-x)
    (for-each (lambda (v)
		 (let ((a (list v pre-x)))
		   (add-arrow! g a)
		   (q-max! a (inf)) (flow! a 0) (q-min! a 0) (cost! a 0)))
	      sinks)
    (add-vertex! g x)
    (let ((a (list pre-x x)))
      (add-arrow! g a)
      (q-max! a constant)
      (flow! a 0) (q-min! a 0) (cost! a 0)))
  
  (define (recover-multiple-sinks! x)
    (remove-vertex! g x)
    (remove-vertex! g (string-append "pre-" (obj->string x))))
  
  (define (morph-restricted-vertices!)
    (define (restricted? v) (or (q-min? v) (q-max? v)))
    (define clon-v    null)
    (define v->clon-v null)
    (define clon-v->j null)
    (for-each (lambda (v)
		 (set! clon-v    (string-append "clon-" (obj->string v)))
		 (set! v->clon-v (list v clon-v))
		 (add-vertex! g clon-v)
		 (clon! v clon-v)
		 (add-arrow! g v->clon-v)
		 (q-min! v->clon-v (if (q-min? v) (q-min v) 0))
		 (q-max! v->clon-v (if (q-max? v) (q-max v) (inf)))
		 (flow! v->clon-v 0)
		 (cost! v->clon-v 0)
		 (for-each (lambda (j)
			      (set! clon-v->j (list clon-v j))
			      (add-arrow! g clon-v->j)
			      (let ((a (list v j)))
				(q-min! clon-v->j (q-min a))
				(q-max! clon-v->j (q-max a))
				(flow!  clon-v->j (flow  a))
				(cost!  clon-v->j (cost  a))
				(remove-arrow! g a)))
			   (remove (lambda (u) (equal? u clon-v)) (out-adjacent g v))))
	      (filter restricted? (vertices g))))
  
  (define (recover-restricted-vertices!)
    (define (restricted? v) (or (q-min? v) (q-max? v)))
    (define clon-v null)
    (for-each (lambda (v)
		 (set! clon-v (clon v))
		 (for-each (lambda (j)
			      (let ((a1 (list v j))
				    (a2 (list clon-v j)))
				(add-arrow! g a1)
				(q-min! a1 (q-min a2))
				(q-max! a1 (q-max a2))
				(flow!  a1 (flow  a2))
				(cost!  a1 (cost  a2))))
			   (out-adjacent g (clon v)))
		 (remove-vertex! g clon-v)
		 (-clon! v))
	      (filter restricted? (vertices g))))
  
  (define (morph-restricted-arrows! x y x* y*)
    (define (add-arrow+atrb! a qmax flw qmin)
      (add-arrow! g a)
      (q-max! a qmax) (flow! a flw) (q-min! a qmin))
    (add-vertices! g (list x* y*))
    (for-each (lambda (a)
		 (let ((a1 (list x* (to a)))
		       (a2 (list (from a) y*)))
		   (if (arrow? g a1)
		       (q-max! a1 (+ (q-min a) (q-max a1)))
		       (add-arrow+atrb! a1 (q-min a) 0 0))
		   (if (arrow? g a2)
		       (q-max! a2 (+ (q-min a) (q-max a2)))
		       (add-arrow+atrb! a2 (q-min a) 0 0))
		   (old-q-min! a (q-min a))
		   (q-max! a (- (q-max a) (q-min a)))
		   (q-min! a 0)))
	      (remove (lambda (a) (zero? (q-min a))) (arrows g)))
    (add-arrow+atrb! (list x y) (inf) 0 0)
    (add-arrow+atrb! (list y x) (inf) 0 0))
  
  (define (recover-restricted-arrows! x y x* y*)
    (remove-arrows! g (list (list x y) (list y x)))
    (for-each (lambda (a)
		(flow!  a (+ (flow a) (old-q-min a)))
		(q-max! a (+ (q-max a) (old-q-min a)))
		(q-min! a (old-q-min a))
		(-old-q-min! a))
	      (filter (lambda (a) (old-q-min? a)) (arrows g)))
    (remove-vertices! g (list x* y*)))

  (define (label! v dir pre flw)
    (direction! v dir)
    (previous!  v pre)
    (flow!      v flw))

  (define (labeled? v)
    (and (direction? v) (previous? v) (flow? v)))

  (define (all-examined?)
    (fold (lambda (x y) (and x y)) #true (map examined? (filter labeled? (vertices g)))))

  (define (examine! v)
    (for-each (lambda (u)
		 (let ((a (list v u)))
		   (when (< (flow a) (q-max a))
		     (label! u '+ v (min (flow v) (- (q-max a) (flow a)))))))
	      (remove (lambda (u) (labeled? u)) (out-adjacent g v)))
    (for-each (lambda (u)
		 (let ((a (list u v)))
		   (when (> (flow a) (q-min a))
		     (label! u '- v (min (flow v) (- (flow a) (q-min a)))))))
	      (remove (lambda (u) (labeled? u)) (in-adjacent g v)))
    (examined! v #true))

  (define (augment-flow! x y)
    (define z y)
    (while (not (equal? z x))
      (let ((p (previous z)))
	(if (equal? (direction z) '+)
	    (flow! (list p z) (+ (flow (list p z)) (flow y)))
	    (flow! (list z p) (- (flow (list z p)) (flow y))))
	(set! z p)))
    (destroy-atributes!)
    (find-augmenting-path! x y))
  
  (define (find-augmenting-path! x y)
    (label! x '+ x (inf))
    (while (and (not (all-examined?)) (not (labeled? y)))
      (examine! (first (filter (lambda (v) (and (not (examined? v)) (labeled? v))) (vertices g)))))
    (when (labeled? y)
      (augment-flow! x y)))

  (define (residual-g H)
    (define (f N a)    (value (atribute N a #:flow)))
    (define (q N a)    (value (atribute N a #:q-max)))
    (define (r N a)    (value (atribute N a #:q-min)))
    (define (c N a)    (value (atribute N a #:cost)))
    (define (q! N a v) (add-atribute! N a #:q-max v))
    (define (c! N a v) (add-atribute! N a #:cost v))
    (define (A! N a v) (add-atribute! N a #:A v))
    (define Hf (make <directed-graph>))
    (for-each (lambda (i->j)
		 (let ((j->i (reverse i->j)))
		   (when (< (f H i->j) (q H i->j))
		     (add-arrow! Hf i->j)
		     (q! Hf i->j (- (q H i->j) (f H i->j)))
		     (c! Hf i->j (c H i->j))
		     (A! Hf i->j 1))
		   (when (> (f H i->j) (r H i->j))
		     (add-arrow! Hf j->i)
		     (q! Hf j->i (- (f H i->j) (r H i->j)))
		     (c! Hf j->i (- (c H i->j)))
		     (A! Hf j->i 2))))
	      (arrows H))
    Hf)

  (define (negative-cycle? lst)
    (and (not (null? lst)) (equal? #:negative-cycle (first lst))))

  (define (negative-cycle->arrows neg-cyc)
    (define path (second neg-cyc))
    (map (lambda (u v) (list u v)) path (cdr path)))

  (define (g-flow)
    (- (apply + (map (lambda (x) (value (atribute g x #:flow))) (outcident g 'alpha)))
       (apply + (map (lambda (x) (value (atribute g x #:flow))) (incident g 'alpha)))))

  (define residual #false)
  (define shrt-path #false)
  (define d #false)
  (define solvable #true)
  
  ;; Algorithm
  (initialize-atributes!)
  (morph-multiple-sources! 'alpha)
  (morph-multiple-sinks! 'omega)
  (set! residual  (residual-g g))
  (set! shrt-path (redijkstra residual 'alpha 'omega #:cost))
  (when (equal? (first shrt-path) #:no-path) (set! solvable #false))
  (when solvable
    (set! d (apply min (map (lambda (a) (value (atribute residual a #:q-max))) shrt-path)))
    (while (and (<= (+ (g-flow) d) constant)
		(not (equal? (first shrt-path) #:no-path)))
      (for-each (lambda (a)
		   (when (arrow? g a)
		     (add-atribute! g a
				    #:flow (+ (value (atribute g a #:flow)) d))))
		shrt-path)
      (set! residual  (residual-g g))
      (set! shrt-path (redijkstra residual 'alpha 'omega #:cost))
      (when (equal? (first shrt-path) #:no-path) (set! solvable #false))
      (when solvable
	(set! d (apply min (map (lambda (a) (value (atribute residual a #:q-max))) shrt-path))))))
  (when (and solvable (> (+ (g-flow) d) constant))
    (let ((v* (g-flow)))
      (for-each (lambda (a)
		   (when (arrow? g a)
		     (add-atribute! g a
				    #:flow (+ (value (atribute g a #:flow))
					      (- constant v*)))))
		shrt-path)))
  (recover-multiple-sources! 'alpha)
  (recover-multiple-sinks! 'omega)
  (destroy-atributes!)
  (let ((return (map (lambda (a) (cons a (value (atribute g a #:flow)))) (arrows g))))
    (remove-arrows-atribute! g #:flow)
    return))
